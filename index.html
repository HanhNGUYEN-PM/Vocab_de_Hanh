<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vocabulary Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>
    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useRef, useCallback } = React;

        const VOCAB_STORAGE_KEY = 'vocabulary-builder-data';
        const REMOTE_SYNC_ENDPOINT = 'https://dweet.io/get/latest/dweet/for/vocab-de-hanh-database';
        const REMOTE_SYNC_PUBLISH_ENDPOINT = 'https://dweet.io/dweet/for/vocab-de-hanh-database';
        const REMOTE_SYNC_QUERY_KEY = 'payload';
        const SYNC_POLL_INTERVAL = 15000;

        const base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        const baseReverseDictionary = {};

        const getBaseValue = (alphabet, character) => {
            if (!baseReverseDictionary[alphabet]) {
                baseReverseDictionary[alphabet] = {};
                for (let index = 0; index < alphabet.length; index += 1) {
                    baseReverseDictionary[alphabet][alphabet.charAt(index)] = index;
                }
            }
            return baseReverseDictionary[alphabet][character] ?? 0;
        };

        const compress = (uncompressed, bitsPerChar, getCharFromInt) => {
            if (uncompressed == null) {
                return '';
            }

            let value;
            const contextDictionary = {};
            const contextDictionaryToCreate = {};
            let contextC = '';
            let contextWC = '';
            let contextW = '';
            let contextEnlargeIn = 2;
            let contextDictSize = 3;
            let contextNumBits = 2;
            const contextData = [];
            let contextDataVal = 0;
            let contextDataPosition = 0;

            for (let ii = 0; ii < uncompressed.length; ii += 1) {
                contextC = uncompressed.charAt(ii);
                if (!Object.prototype.hasOwnProperty.call(contextDictionary, contextC)) {
                    contextDictionary[contextC] = contextDictSize;
                    contextDictSize += 1;
                    contextDictionaryToCreate[contextC] = true;
                }

                contextWC = contextW + contextC;

                if (Object.prototype.hasOwnProperty.call(contextDictionary, contextWC)) {
                    contextW = contextWC;
                    continue;
                }

                if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {
                    const charCode = contextW.charCodeAt(0);
                    if (charCode < 256) {
                        for (let i = 0; i < contextNumBits; i += 1) {
                            contextDataVal <<= 1;
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                        }
                        let valueToStore = charCode;
                        for (let i = 0; i < 8; i += 1) {
                            contextDataVal = (contextDataVal << 1) | (valueToStore & 1);
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            valueToStore >>= 1;
                        }
                    } else {
                        value = 1;
                        for (let i = 0; i < contextNumBits; i += 1) {
                            contextDataVal = (contextDataVal << 1) | value;
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            value = 0;
                        }
                        let valueToStore = contextW.charCodeAt(0);
                        for (let i = 0; i < 16; i += 1) {
                            contextDataVal = (contextDataVal << 1) | (valueToStore & 1);
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            valueToStore >>= 1;
                        }
                    }
                    contextEnlargeIn -= 1;
                    if (contextEnlargeIn === 0) {
                        contextEnlargeIn = 2 ** contextNumBits;
                        contextNumBits += 1;
                    }
                    delete contextDictionaryToCreate[contextW];
                } else {
                    value = contextDictionary[contextW];
                    for (let i = 0; i < contextNumBits; i += 1) {
                        contextDataVal = (contextDataVal << 1) | (value & 1);
                        if (contextDataPosition === bitsPerChar - 1) {
                            contextDataPosition = 0;
                            contextData.push(getCharFromInt(contextDataVal));
                            contextDataVal = 0;
                        } else {
                            contextDataPosition += 1;
                        }
                        value >>= 1;
                    }
                }

                contextEnlargeIn -= 1;
                if (contextEnlargeIn === 0) {
                    contextEnlargeIn = 2 ** contextNumBits;
                    contextNumBits += 1;
                }

                contextDictionary[contextWC] = contextDictSize;
                contextDictSize += 1;
                contextW = String(contextC);
            }

            if (contextW !== '') {
                if (Object.prototype.hasOwnProperty.call(contextDictionaryToCreate, contextW)) {
                    const charCode = contextW.charCodeAt(0);
                    if (charCode < 256) {
                        for (let i = 0; i < contextNumBits; i += 1) {
                            contextDataVal <<= 1;
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                        }
                        let valueToStore = charCode;
                        for (let i = 0; i < 8; i += 1) {
                            contextDataVal = (contextDataVal << 1) | (valueToStore & 1);
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            valueToStore >>= 1;
                        }
                    } else {
                        value = 1;
                        for (let i = 0; i < contextNumBits; i += 1) {
                            contextDataVal = (contextDataVal << 1) | value;
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            value = 0;
                        }
                        let valueToStore = contextW.charCodeAt(0);
                        for (let i = 0; i < 16; i += 1) {
                            contextDataVal = (contextDataVal << 1) | (valueToStore & 1);
                            if (contextDataPosition === bitsPerChar - 1) {
                                contextDataPosition = 0;
                                contextData.push(getCharFromInt(contextDataVal));
                                contextDataVal = 0;
                            } else {
                                contextDataPosition += 1;
                            }
                            valueToStore >>= 1;
                        }
                    }
                    delete contextDictionaryToCreate[contextW];
                } else {
                    value = contextDictionary[contextW];
                    for (let i = 0; i < contextNumBits; i += 1) {
                        contextDataVal = (contextDataVal << 1) | (value & 1);
                        if (contextDataPosition === bitsPerChar - 1) {
                            contextDataPosition = 0;
                            contextData.push(getCharFromInt(contextDataVal));
                            contextDataVal = 0;
                        } else {
                            contextDataPosition += 1;
                        }
                        value >>= 1;
                    }
                }
                contextEnlargeIn -= 1;
                if (contextEnlargeIn === 0) {
                    contextEnlargeIn = 2 ** contextNumBits;
                    contextNumBits += 1;
                }
            }

            value = 2;
            for (let i = 0; i < contextNumBits; i += 1) {
                contextDataVal = (contextDataVal << 1) | (value & 1);
                if (contextDataPosition === bitsPerChar - 1) {
                    contextDataPosition = 0;
                    contextData.push(getCharFromInt(contextDataVal));
                    contextDataVal = 0;
                } else {
                    contextDataPosition += 1;
                }
                value >>= 1;
            }

            while (true) {
                contextDataVal <<= 1;
                if (contextDataPosition === bitsPerChar - 1) {
                    contextData.push(getCharFromInt(contextDataVal));
                    break;
                } else {
                    contextDataPosition += 1;
                }
            }

            return contextData.join('');
        };

        const decompress = (length, resetValue, getNextValue) => {
            const dictionary = [];
            let next;
            let enlargeIn = 4;
            let dictSize = 4;
            let numBits = 3;
            let entry = '';
            const result = [];
            let w = '';
            let bits;
            let resb;
            let maxPower;
            let power;

            const data = {
                value: getNextValue(0),
                position: resetValue,
                index: 1,
            };

            for (let i = 0; i < 3; i += 1) {
                dictionary[i] = String.fromCharCode(i);
            }

            bits = 0;
            maxPower = 2;
            power = 1;
            while (power !== maxPower) {
                resb = data.value & data.position;
                data.position >>= 1;
                if (data.position === 0) {
                    data.position = resetValue;
                    data.value = getNextValue(data.index);
                    data.index += 1;
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
            }

            switch (bits) {
                case 0: {
                    bits = 0;
                    maxPower = 256;
                    power = 1;
                    while (power !== maxPower) {
                        resb = data.value & data.position;
                        data.position >>= 1;
                        if (data.position === 0) {
                            data.position = resetValue;
                            data.value = getNextValue(data.index);
                            data.index += 1;
                        }
                        bits |= (resb > 0 ? 1 : 0) * power;
                        power <<= 1;
                    }
                    dictionary[3] = String.fromCharCode(bits);
                    w = dictionary[3];
                    break;
                }
                case 1: {
                    bits = 0;
                    maxPower = 65536;
                    power = 1;
                    while (power !== maxPower) {
                        resb = data.value & data.position;
                        data.position >>= 1;
                        if (data.position === 0) {
                            data.position = resetValue;
                            data.value = getNextValue(data.index);
                            data.index += 1;
                        }
                        bits |= (resb > 0 ? 1 : 0) * power;
                        power <<= 1;
                    }
                    dictionary[3] = String.fromCharCode(bits);
                    w = dictionary[3];
                    break;
                }
                case 2:
                    return '';
                default:
                    return null;
            }

            result.push(w);

            while (true) {
                if (data.index > length) {
                    return result.join('');
                }

                bits = 0;
                maxPower = 2 ** numBits;
                power = 1;
                while (power !== maxPower) {
                    resb = data.value & data.position;
                    data.position >>= 1;
                    if (data.position === 0) {
                        data.position = resetValue;
                        data.value = getNextValue(data.index);
                        data.index += 1;
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                }

                next = bits;

                if (next === 0) {
                    bits = 0;
                    maxPower = 256;
                    power = 1;
                    while (power !== maxPower) {
                        resb = data.value & data.position;
                        data.position >>= 1;
                        if (data.position === 0) {
                            data.position = resetValue;
                            data.value = getNextValue(data.index);
                            data.index += 1;
                        }
                        bits |= (resb > 0 ? 1 : 0) * power;
                        power <<= 1;
                    }
                    dictionary[dictSize] = String.fromCharCode(bits);
                    dictSize += 1;
                    next = dictSize - 1;
                    enlargeIn -= 1;
                } else if (next === 1) {
                    bits = 0;
                    maxPower = 65536;
                    power = 1;
                    while (power !== maxPower) {
                        resb = data.value & data.position;
                        data.position >>= 1;
                        if (data.position === 0) {
                            data.position = resetValue;
                            data.value = getNextValue(data.index);
                            data.index += 1;
                        }
                        bits |= (resb > 0 ? 1 : 0) * power;
                        power <<= 1;
                    }
                    dictionary[dictSize] = String.fromCharCode(bits);
                    dictSize += 1;
                    next = dictSize - 1;
                    enlargeIn -= 1;
                } else if (next === 2) {
                    return result.join('');
                }

                if (enlargeIn === 0) {
                    enlargeIn = 2 ** numBits;
                    numBits += 1;
                }

                if (dictionary[next]) {
                    entry = dictionary[next];
                } else if (next === dictSize) {
                    entry = w + w.charAt(0);
                } else {
                    return null;
                }

                result.push(entry);

                dictionary[dictSize] = w + entry.charAt(0);
                dictSize += 1;
                enlargeIn -= 1;

                w = entry;

                if (enlargeIn === 0) {
                    enlargeIn = 2 ** numBits;
                    numBits += 1;
                }
            }
        };

        const compressToBase64 = (input) => {
            if (input == null) {
                return '';
            }
            const compressed = compress(input, 6, (value) => base64Characters.charAt(value));
            switch (compressed.length % 4) {
                case 0:
                    return compressed;
                case 1:
                    return `${compressed}===`;
                case 2:
                    return `${compressed}==`;
                case 3:
                    return `${compressed}=`;
                default:
                    return compressed;
            }
        };

        const decompressFromBase64 = (input) => {
            if (input == null || input === '') {
                return null;
            }
            const sanitized = input.replace(/[^A-Za-z0-9+/=]/g, '');
            return decompress(sanitized.length, 32, (index) => getBaseValue(base64Characters, sanitized.charAt(index)));
        };

        const encodeRemotePayload = (items, revision) => {
            try {
                const payload = JSON.stringify({ vocabulary: items, updatedAt: revision });
                return compressToBase64(payload);
            } catch (error) {
                console.error('Failed to encode remote payload:', error);
            }

            return null;
        };

        const decodeRemotePayload = (payload) => {
            try {
                const jsonText = decompressFromBase64(payload);
                if (!jsonText) {
                    return null;
                }

                const parsed = JSON.parse(jsonText);
                if (
                    parsed &&
                    typeof parsed === 'object' &&
                    Array.isArray(parsed.vocabulary) &&
                    typeof parsed.updatedAt === 'number'
                ) {
                    return parsed;
                }
            } catch (error) {
                console.error('Failed to decode remote payload:', error);
            }

            return null;
        };

        const generateId = (prefix) => {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        };

        const formatRelativeTime = (timestamp) => {
            const diff = Date.now() - timestamp;
            if (diff < 10000) {
                return 'il y a quelques secondes';
            }
            if (diff < 60000) {
                const seconds = Math.floor(diff / 1000);
                return `il y a ${seconds} seconde${seconds > 1 ? 's' : ''}`;
            }
            if (diff < 3600000) {
                const minutes = Math.floor(diff / 60000);
                return `il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
            }
            if (diff < 86400000) {
                const hours = Math.floor(diff / 3600000);
                return `il y a ${hours} heure${hours > 1 ? 's' : ''}`;
            }
            const days = Math.floor(diff / 86400000);
            return `il y a ${days} jour${days > 1 ? 's' : ''}`;
        };

        const sanitizeVocabulary = (items) =>
            (Array.isArray(items) ? items : [])
                .filter((item) => item && typeof item === 'object')
                .map((item, index) => ({
                    id: typeof item.id === 'string' && item.id.trim() ? item.id : generateId(`remote-${index}`),
                    vietnamese: typeof item.vietnamese === 'string' ? item.vietnamese.trim() : '',
                    chinese: typeof item.chinese === 'string' ? item.chinese.trim() : '',
                    pinyin: typeof item.pinyin === 'string' ? item.pinyin.trim() : '',
                    phonetic: typeof item.phonetic === 'string' ? item.phonetic.trim() : '',
                    hanViet: typeof item.hanViet === 'string' ? item.hanViet.trim() : '',
                    isFavorite: Boolean(item.isFavorite),
                }))
                .filter((item) => item.vietnamese && item.chinese && item.pinyin && item.phonetic && item.hanViet);

        const PlusIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
            </svg>
        );

        const LearnIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" />
            </svg>
        );

        const ManageIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 6.75h7.5M8.25 12h7.5m-7.5 5.25h7.5M3.75 6.75h.007v.008H3.75V6.75zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zM3.75 12h.007v.008H3.75V12zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm-.375 5.25h.007v.008H3.75v-.008zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
            </svg>
        );

        const ChevronDownIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
            </svg>
        );

        const CheckIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
            </svg>
        );

        const XIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        );

        const EditIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
            </svg>
        );

        const DeleteIcon = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.067-2.09 1.02-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" />
            </svg>
        );

        const PLACEHOLDER_TEXT = `Paste your vocabulary here. Each line should have 5 parts separated by tabs.
Example:
Ngân hàng       银行    yínháng dính háng       ngân hàng
Bưu điện        邮局    yóujú   dấu chú bưu cục
...`;

        const VocabularyInput = ({ onSave, existingVocabulary }) => {
            const [text, setText] = useState('');
            const [error, setError] = useState(null);
            const [successMessage, setSuccessMessage] = useState(null);

            const handleParseAndSave = () => {
                setError(null);
                setSuccessMessage(null);
                if (!text.trim()) {
                    setError('Input cannot be empty.');
                    return;
                }

                const lines = text.trim().split('\n');
                const newItems = [];
                let lineError = false;
                const existingVietnameseWords = new Set(existingVocabulary.map((item) => item.vietnamese));
                let skippedCount = 0;

                lines.forEach((line, index) => {
                    if (lineError || !line.trim()) {
                        return;
                    }

                    const parts = line.split('\t');
                    if (parts.length !== 5) {
                        setError(`Error on line ${index + 1}: Each line must have exactly 5 parts separated by a tab.`);
                        lineError = true;
                        return;
                    }

                    const [vietnamese, chinese, pinyin, phonetic, hanViet] = parts.map((p) => p.trim());
                    if (!vietnamese || !chinese || !pinyin || !phonetic || !hanViet) {
                        setError(`Error on line ${index + 1}: One of the parts is empty.`);
                        lineError = true;
                        return;
                    }

                    if (existingVietnameseWords.has(vietnamese)) {
                        skippedCount += 1;
                        return;
                    }

                    newItems.push({
                        id: `${Date.now()}-${index}`,
                        vietnamese,
                        chinese,
                        pinyin,
                        phonetic,
                        hanViet,
                        isFavorite: false,
                    });
                });

                if (lineError) {
                    return;
                }

                if (existingVocabulary.length + newItems.length < 3) {
                    setError('You need a total of at least 3 vocabulary words to start the quiz.');
                    return;
                }

                if (newItems.length > 0) {
                    onSave(newItems);
                    setSuccessMessage(`${newItems.length} new word(s) added! ${skippedCount > 0 ? `${skippedCount} duplicate(s) skipped.` : ''}`);
                    setText('');
                } else if (skippedCount > 0) {
                    setError(`All ${skippedCount} entered word(s) were duplicates and have been skipped.`);
                } else {
                    setError('No new words to add.');
                }
            };

            return (
                <div className="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-lg animate-fade-in">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold text-slate-700">Add New Vocabulary</h2>
                        <div className="text-sm font-medium text-slate-500 bg-slate-200 px-3 py-1 rounded-full">
                            {existingVocabulary.length} words in collection
                        </div>
                    </div>
                    <p className="text-slate-600 mb-6">
                        Paste your vocabulary list below. New words will be added to your existing collection. Duplicates will be skipped.
                    </p>

                    <textarea
                        value={text}
                        onChange={(event) => setText(event.target.value)}
                        placeholder={PLACEHOLDER_TEXT}
                        className="w-full h-64 p-4 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-shadow duration-200 resize-none font-mono text-sm"
                    />

                    {error && <p className="text-red-500 mt-4 text-sm font-semibold">{error}</p>}
                    {successMessage && <p className="text-green-600 mt-4 text-sm font-semibold">{successMessage}</p>}

                    <div className="mt-6 flex justify-end">
                        <button
                            onClick={handleParseAndSave}
                            className="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105"
                        >
                            Add Words to Collection
                        </button>
                    </div>
                </div>
            );
        };

        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i -= 1) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        const Quiz = ({ vocabulary, title }) => {
            const [quizQuestions, setQuizQuestions] = useState([]);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [score, setScore] = useState(0);
            const [choices, setChoices] = useState([]);
            const [selectedAnswerId, setSelectedAnswerId] = useState(null);
            const [isAnswered, setIsAnswered] = useState(false);
            const [isFinished, setIsFinished] = useState(false);
            const autoAdvanceTimeoutRef = useRef(null);

            const generateNewQuiz = useCallback(() => {
                if (autoAdvanceTimeoutRef.current) {
                    window.clearTimeout(autoAdvanceTimeoutRef.current);
                    autoAdvanceTimeoutRef.current = null;
                }
                const shuffledVocabulary = shuffleArray(vocabulary);
                const questionsForQuiz = shuffledVocabulary.slice(0, Math.min(10, vocabulary.length));
                setQuizQuestions(questionsForQuiz);
                setCurrentQuestionIndex(0);
                setScore(0);
                setSelectedAnswerId(null);
                setIsAnswered(false);
                setIsFinished(false);
            }, [vocabulary]);

            useEffect(() => {
                if (vocabulary.length >= 3) {
                    generateNewQuiz();
                }
            }, [vocabulary, generateNewQuiz]);

            useEffect(() => {
                const currentQuestion = quizQuestions[currentQuestionIndex];
                if (!currentQuestion) {
                    return;
                }
                const incorrectAnswers = vocabulary.filter((item) => item.id !== currentQuestion.id);
                const options = shuffleArray([
                    currentQuestion,
                    ...shuffleArray(incorrectAnswers).slice(0, 2),
                ]);
                setChoices(options);
            }, [quizQuestions, currentQuestionIndex, vocabulary]);

            const currentQuestion = quizQuestions[currentQuestionIndex];

            useEffect(() => () => {
                if (autoAdvanceTimeoutRef.current) {
                    window.clearTimeout(autoAdvanceTimeoutRef.current);
                }
            }, []);

            const handleAnswer = (selectedId) => {
                if (isAnswered) {
                    return;
                }
                setSelectedAnswerId(selectedId);
                setIsAnswered(true);
                if (currentQuestion && selectedId === currentQuestion.id) {
                    setScore((prev) => prev + 1);
                }
                if (autoAdvanceTimeoutRef.current) {
                    window.clearTimeout(autoAdvanceTimeoutRef.current);
                }
                autoAdvanceTimeoutRef.current = window.setTimeout(() => {
                    handleNextQuestion();
                }, 600);
            };

            const handleNextQuestion = () => {
                if (currentQuestionIndex < quizQuestions.length - 1) {
                    setCurrentQuestionIndex((prev) => prev + 1);
                    setSelectedAnswerId(null);
                    setIsAnswered(false);
                } else {
                    setIsFinished(true);
                }
                autoAdvanceTimeoutRef.current = null;
            };

            if (isFinished) {
                return (
                    <div className="max-w-2xl mx-auto text-center bg-white p-8 rounded-lg shadow-lg">
                        <h2 className="text-3xl font-bold mb-4 text-slate-700">Quiz Complete!</h2>
                        <p className="text-xl text-slate-600 mb-6">Your final score is:</p>
                        <p className="text-6xl font-bold text-indigo-600 mb-8">{score} / {quizQuestions.length}</p>
                        <button
                            onClick={generateNewQuiz}
                            className="px-8 py-4 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105"
                        >
                            Start New Quiz
                        </button>
                    </div>
                );
            }

            if (!currentQuestion) {
                return <div className="text-center text-slate-500">Loading quiz...</div>;
            }

            const getChoiceClass = (choiceId) => {
                if (!isAnswered) {
                    return 'bg-white hover:bg-indigo-50 border-slate-300';
                }
                if (choiceId === currentQuestion.id) {
                    return 'bg-green-100 border-green-500 ring-2 ring-green-500';
                }
                if (choiceId === selectedAnswerId) {
                    return 'bg-red-100 border-red-500 ring-2 ring-red-500';
                }
                return 'bg-slate-50 border-slate-200 opacity-60';
            };

            return (
                <div className="max-w-2xl mx-auto">
                    <div className="text-center mb-4">
                        <h1 className="text-xl font-bold text-slate-600">{title}</h1>
                    </div>
                    <div className="flex justify-between items-center mb-2">
                        <div className="text-sm text-slate-500">
                            Question {currentQuestionIndex + 1} of {quizQuestions.length}
                        </div>
                        <div className="text-sm font-semibold text-slate-600 bg-slate-200 px-3 py-1 rounded-full">
                            Score: {score}
                        </div>
                    </div>
                    <div className="bg-white p-8 rounded-lg shadow-lg mb-6 text-center">
                        <p className="text-lg text-slate-500 mb-2">What is the meaning of:</p>
                        <h2 className="text-4xl font-bold text-slate-800">{currentQuestion.vietnamese}</h2>
                    </div>
                    <div className="grid grid-cols-1 gap-4">
                        {choices.map((choice) => (
                            <button
                                key={choice.id}
                                onClick={() => handleAnswer(choice.id)}
                                disabled={isAnswered}
                                className={`p-6 rounded-lg border-2 text-left transition-all duration-300 transform hover:scale-105 disabled:cursor-not-allowed disabled:transform-none ${getChoiceClass(choice.id)}`}
                            >
                                <div className="flex justify-between items-center">
                                    <div>
                                        <p className="text-2xl font-semibold text-slate-800">{choice.pinyin}</p>
                                        <p className="text-sm text-slate-500 mt-1">{choice.phonetic} • {choice.hanViet}</p>
                                    </div>
                                    {isAnswered && (
                                        choice.id === currentQuestion.id ? <CheckIcon className="w-8 h-8 text-green-600" /> :
                                            choice.id === selectedAnswerId ? <XIcon className="w-8 h-8 text-red-600" /> : null
                                    )}
                                </div>
                            </button>
                        ))}
                    </div>
                    {isAnswered && (
                        <div className="mt-8 text-center text-slate-500 text-sm">
                            {currentQuestionIndex < quizQuestions.length - 1
                                ? 'Chargement de la question suivante...'
                                : 'Affichage des résultats...'}
                        </div>
                    )}
                </div>
            );
        };

        const VocabularyManager = ({ vocabulary, onUpdate, onDelete }) => {
            const [editingId, setEditingId] = useState(null);
            const [editedItem, setEditedItem] = useState(null);

            const handleEdit = (item) => {
                setEditingId(item.id);
                setEditedItem({ ...item });
            };

            const handleCancel = () => {
                setEditingId(null);
                setEditedItem(null);
            };

            const handleSave = () => {
                if (editedItem) {
                    onUpdate(editedItem);
                }
                handleCancel();
            };

            const handleDelete = (id, vietnamese) => {
                if (window.confirm(`Are you sure you want to delete "${vietnamese}"?`)) {
                    onDelete(id);
                }
            };

            const handleInputChange = (event) => {
                if (editedItem) {
                    setEditedItem({ ...editedItem, [event.target.name]: event.target.value });
                }
            };

            const renderCell = (field, item) => {
                if (editingId === item.id && editedItem) {
                    return (
                        <input
                            type="text"
                            name={field}
                            value={editedItem[field]}
                            onChange={handleInputChange}
                            className="w-full bg-slate-50 border border-indigo-300 rounded-md px-2 py-1 focus:ring-2 focus:ring-indigo-500 focus:outline-none"
                        />
                    );
                }
                return item[field];
            };

            return (
                <div className="bg-white p-6 md:p-8 rounded-lg shadow-lg animate-fade-in">
                    <h2 className="text-2xl font-bold text-slate-700 mb-6">Manage Vocabulary Collection</h2>
                    <div className="overflow-x-auto">
                        <table className="w-full min-w-[800px] text-sm text-left text-slate-600">
                            <thead className="text-xs text-slate-700 uppercase bg-slate-100">
                                <tr>
                                    <th scope="col" className="px-4 py-3">Vietnamese</th>
                                    <th scope="col" className="px-4 py-3">Chinese</th>
                                    <th scope="col" className="px-4 py-3">Pinyin</th>
                                    <th scope="col" className="px-4 py-3">Phonetic</th>
                                    <th scope="col" className="px-4 py-3">Hán Việt</th>
                                    <th scope="col" className="px-4 py-3 text-right">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {vocabulary.map((item) => (
                                    <tr key={item.id} className="bg-white border-b hover:bg-slate-50">
                                        <td className="px-4 py-3">{renderCell('vietnamese', item)}</td>
                                        <td className="px-4 py-3">{renderCell('chinese', item)}</td>
                                        <td className="px-4 py-3">{renderCell('pinyin', item)}</td>
                                        <td className="px-4 py-3">{renderCell('phonetic', item)}</td>
                                        <td className="px-4 py-3">{renderCell('hanViet', item)}</td>
                                        <td className="px-4 py-3">
                                            <div className="flex justify-end items-center space-x-2">
                                                {editingId === item.id ? (
                                                    <>
                                                        <button onClick={handleSave} className="p-2 text-green-600 hover:text-green-800 rounded-full hover:bg-green-100" title="Save">
                                                            <CheckIcon className="w-5 h-5" />
                                                        </button>
                                                        <button onClick={handleCancel} className="p-2 text-slate-500 hover:text-slate-700 rounded-full hover:bg-slate-200" title="Cancel">
                                                            <XIcon className="w-5 h-5" />
                                                        </button>
                                                    </>
                                                ) : (
                                                    <>
                                                        <button onClick={() => handleEdit(item)} className="p-2 text-blue-600 hover:text-blue-800 rounded-full hover:bg-blue-100" title="Edit">
                                                            <EditIcon className="w-5 h-5" />
                                                        </button>
                                                        <button onClick={() => handleDelete(item.id, item.vietnamese)} className="p-2 text-red-600 hover:text-red-800 rounded-full hover:bg-red-100" title="Delete">
                                                            <DeleteIcon className="w-5 h-5" />
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [vocabulary, setVocabulary] = useState([]);
            const [view, setView] = useState('add');
            const [isLearnDropdownOpen, setIsLearnDropdownOpen] = useState(false);
            const [quizScope, setQuizScope] = useState(null);
            const [isSyncReady, setIsSyncReady] = useState(false);
            const [syncStatus, setSyncStatus] = useState('idle');
            const [syncError, setSyncError] = useState(null);
            const [lastSyncedAt, setLastSyncedAt] = useState(null);

            const learnButtonRef = useRef(null);
            const skipNextPushRef = useRef(false);
            const localRevisionRef = useRef(0);

            const persistVocabularyLocally = useCallback((items, revision) => {
                try {
                    const payload = { vocabulary: items, updatedAt: revision };
                    localStorage.setItem(VOCAB_STORAGE_KEY, JSON.stringify(payload));
                } catch (error) {
                    console.error('Failed to save vocabulary to local storage:', error);
                }
            }, []);

            const pushRemoteVocabulary = useCallback(async (items, revision) => {
                if (!isSyncReady) {
                    return;
                }

                try {
                    const encoded = encodeRemotePayload(items, revision);
                    if (!encoded) {
                        throw new Error('Encoded payload is empty');
                    }

                    setSyncStatus('syncing');
                    setSyncError(null);
                    const url = `${REMOTE_SYNC_PUBLISH_ENDPOINT}?${REMOTE_SYNC_QUERY_KEY}=${encodeURIComponent(encoded)}&stamp=${revision}`;
                    const response = await fetch(url, {
                        method: 'GET',
                        cache: 'no-store',
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    await response.json().catch(() => null);
                    setSyncStatus('idle');
                    setLastSyncedAt(Date.now());
                } catch (error) {
                    console.error('Failed to sync vocabulary to remote storage:', error);
                    setSyncStatus('error');
                    setSyncError('La synchronisation automatique a échoué. Vos données sont enregistrées localement.');
                }
            }, [isSyncReady]);

            const applyRemoteVocabulary = useCallback((items, revision) => {
                const sanitized = sanitizeVocabulary(items);
                skipNextPushRef.current = true;
                localRevisionRef.current = revision;
                persistVocabularyLocally(sanitized, revision);
                setVocabulary(sanitized);
                setLastSyncedAt(Date.now());
                setSyncStatus('idle');
                setSyncError(null);

                setView((previousView) => {
                    if (sanitized.length === 0) {
                        return 'add';
                    }
                    if (sanitized.length < 3 && previousView === 'learn') {
                        return 'add';
                    }
                    if (sanitized.length >= 3 && previousView === 'add') {
                        return 'learn';
                    }
                    return previousView;
                });

                setQuizScope((previousScope) => {
                    if (sanitized.length < 3) {
                        return null;
                    }
                    return previousScope || 'all';
                });
            }, [persistVocabularyLocally]);

            const fetchRemoteVocabulary = useCallback(async () => {
                if (!isSyncReady) {
                    return;
                }

                try {
                    const response = await fetch(REMOTE_SYNC_ENDPOINT, { method: 'GET', cache: 'no-store' });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const payload = await response.json().catch(() => null);
                    if (!payload) {
                        return;
                    }

                    const remotePayload =
                        payload && typeof payload === 'object' && Array.isArray(payload.with)
                            ? payload.with[0]?.content || null
                            : null;

                    if (!remotePayload || typeof remotePayload !== 'object') {
                        return;
                    }

                    const encodedContent = remotePayload[REMOTE_SYNC_QUERY_KEY];
                    if (typeof encodedContent !== 'string' || !encodedContent.trim()) {
                        return;
                    }

                    const decoded = decodeRemotePayload(encodedContent.trim());
                    if (!decoded) {
                        return;
                    }

                    const remoteItems = Array.isArray(decoded.vocabulary) ? decoded.vocabulary : [];
                    const sanitized = sanitizeVocabulary(remoteItems);
                    const effectiveRevision =
                        typeof decoded.updatedAt === 'number' && decoded.updatedAt > 0 ? decoded.updatedAt : Date.now();

                    if (!sanitized.length) {
                        if (effectiveRevision > localRevisionRef.current && vocabulary.length > 0) {
                            applyRemoteVocabulary([], effectiveRevision);
                        }
                        return;
                    }

                    if (
                        effectiveRevision > localRevisionRef.current ||
                        (localRevisionRef.current === 0 && vocabulary.length === 0)
                    ) {
                        applyRemoteVocabulary(sanitized, effectiveRevision);
                    }
                } catch (error) {
                    console.error('Failed to pull vocabulary from remote storage:', error);
                    setSyncError((previous) => previous || "Impossible de contacter le service de synchronisation automatique pour l'instant.");
                }
            }, [applyRemoteVocabulary, isSyncReady, vocabulary]);

            useEffect(() => {
                try {
                    const storedData = localStorage.getItem(VOCAB_STORAGE_KEY);
                    let initialVocabulary = [];
                    let initialRevision = 0;

                    if (storedData) {
                        const parsed = JSON.parse(storedData);
                        if (Array.isArray(parsed)) {
                            initialVocabulary = sanitizeVocabulary(parsed);
                            initialRevision = Date.now();
                            persistVocabularyLocally(initialVocabulary, initialRevision);
                        } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.vocabulary)) {
                            initialVocabulary = sanitizeVocabulary(parsed.vocabulary);
                            initialRevision = typeof parsed.updatedAt === 'number' ? parsed.updatedAt : Date.now();
                        }
                    }

                    if (initialVocabulary.length) {
                        setVocabulary(initialVocabulary);
                        if (initialVocabulary.length >= 3) {
                            setView('learn');
                            setQuizScope('all');
                        }
                    }

                    skipNextPushRef.current = true;
                    localRevisionRef.current = initialRevision;
                    setIsSyncReady(true);
                } catch (error) {
                    console.error('Failed to load vocabulary from local storage:', error);
                }
            }, [persistVocabularyLocally]);

            useEffect(() => {
                if (!isSyncReady) {
                    return;
                }

                fetchRemoteVocabulary();
                const interval = window.setInterval(() => {
                    fetchRemoteVocabulary();
                }, SYNC_POLL_INTERVAL);

                return () => window.clearInterval(interval);
            }, [fetchRemoteVocabulary, isSyncReady]);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (learnButtonRef.current && !learnButtonRef.current.contains(event.target)) {
                        setIsLearnDropdownOpen(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, []);

            const handleSaveVocabulary = useCallback((newItems) => {
                if (!newItems.length) {
                    return;
                }

                let shouldSwitchToLearn = false;

                setVocabulary((previousVocabulary) => {
                    const updatedVocabulary = [...previousVocabulary, ...newItems];
                    shouldSwitchToLearn = updatedVocabulary.length >= 3;
                    const revision = Date.now();
                    persistVocabularyLocally(updatedVocabulary, revision);
                    localRevisionRef.current = revision;

                    if (skipNextPushRef.current) {
                        skipNextPushRef.current = false;
                    } else {
                        pushRemoteVocabulary(updatedVocabulary, revision);
                    }

                    return updatedVocabulary;
                });

                if (shouldSwitchToLearn) {
                    setView('learn');
                    setQuizScope('recent');
                }
            }, [persistVocabularyLocally, pushRemoteVocabulary]);

            const handleDeleteVocabularyItem = useCallback((idToDelete) => {
                let updatedLength = 0;
                let changed = false;

                setVocabulary((previousVocabulary) => {
                    const updatedVocabulary = previousVocabulary.filter((item) => item.id !== idToDelete);
                    if (updatedVocabulary.length === previousVocabulary.length) {
                        updatedLength = previousVocabulary.length;
                        return previousVocabulary;
                    }

                    changed = true;
                    updatedLength = updatedVocabulary.length;
                    const revision = Date.now();
                    persistVocabularyLocally(updatedVocabulary, revision);
                    localRevisionRef.current = revision;

                    if (skipNextPushRef.current) {
                        skipNextPushRef.current = false;
                    } else {
                        pushRemoteVocabulary(updatedVocabulary, revision);
                    }

                    return updatedVocabulary;
                });

                if (!changed) {
                    return;
                }

                setView((previousView) => {
                    if (updatedLength === 0) {
                        return 'add';
                    }
                    if (updatedLength < 3 && previousView === 'learn') {
                        return 'add';
                    }
                    return previousView;
                });

                setQuizScope((previousScope) => (updatedLength < 3 ? null : previousScope));
            }, [persistVocabularyLocally, pushRemoteVocabulary]);

            const handleUpdateVocabularyItem = useCallback((updatedItem) => {
                let changed = false;

                setVocabulary((previousVocabulary) => {
                    const updatedVocabulary = previousVocabulary.map((item) => {
                        if (item.id === updatedItem.id) {
                            changed = true;
                            return { ...item, ...updatedItem };
                        }
                        return item;
                    });

                    if (!changed) {
                        return previousVocabulary;
                    }

                    const revision = Date.now();
                    persistVocabularyLocally(updatedVocabulary, revision);
                    localRevisionRef.current = revision;

                    if (skipNextPushRef.current) {
                        skipNextPushRef.current = false;
                    } else {
                        pushRemoteVocabulary(updatedVocabulary, revision);
                    }

                    return updatedVocabulary;
                });
            }, [persistVocabularyLocally, pushRemoteVocabulary]);

            const handleStartQuiz = (scope) => {
                setQuizScope(scope);
                setView('learn');
                setIsLearnDropdownOpen(false);
            };

            const hasEnoughVocabularyForQuiz = vocabulary.length >= 3;
            const hasAnyVocabulary = vocabulary.length > 0;

            const renderContent = () => {
                if (view === 'add') {
                    return <VocabularyInput onSave={handleSaveVocabulary} existingVocabulary={vocabulary} />;
                }

                if (view === 'learn') {
                    if (!quizScope || !hasEnoughVocabularyForQuiz) {
                        return (
                            <div className="text-center p-8 bg-white rounded-lg shadow-lg">
                                <h2 className="text-2xl font-bold text-slate-700 mb-4">Bienvenue !</h2>
                                <p className="text-slate-600">Ajoutez au moins 3 mots de vocabulaire pour démarrer un quiz.</p>
                                <p className="text-slate-600">Rendez-vous dans l'onglet « Ajouter des mots » pour compléter votre liste.</p>
                            </div>
                        );
                    }
                    const quizTitle = quizScope === 'recent' ? 'Quiz : 30 derniers mots' : 'Quiz : Tous les mots';
                    const quizVocabulary = quizScope === 'recent' ? vocabulary.slice(-30) : vocabulary;
                    return <Quiz vocabulary={quizVocabulary} title={quizTitle} />;
                }

                if (view === 'manage') {
                    return hasAnyVocabulary ? (
                        <VocabularyManager
                            vocabulary={vocabulary}
                            onUpdate={handleUpdateVocabularyItem}
                            onDelete={handleDeleteVocabularyItem}
                        />
                    ) : (
                        <div className="text-center p-8 bg-white rounded-lg shadow-lg">
                            <h2 className="text-2xl font-bold text-slate-700 mb-4">Aucun mot à gérer</h2>
                            <p className="text-slate-600">Votre collection de vocabulaire est vide.</p>
                            <p className="text-slate-600">Ajoutez quelques mots dans l'onglet « Ajouter des mots ».</p>
                        </div>
                    );
                }

                return null;
            };

            const syncStatusLabel = syncStatus === 'syncing'
                ? 'Synchronisation automatique en cours…'
                : syncError || (lastSyncedAt ? `Synchronisé automatiquement ${formatRelativeTime(lastSyncedAt)}` : 'Synchronisation automatique activée');

            return (
                <div className="min-h-screen bg-slate-100 text-slate-800 font-sans">
                    <header className="bg-white shadow-md">
                        <div className="container mx-auto px-4 py-4 flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
                            <div>
                                <h1 className="text-2xl font-bold text-slate-700 tracking-tight">Vocabulary Builder</h1>
                                <p className={`text-xs mt-1 ${syncStatus === 'error' ? 'text-red-600' : 'text-slate-500'}`}>{syncStatusLabel}</p>
                            </div>
                            <nav className="flex flex-wrap gap-2">
                                <button
                                    onClick={() => setView('add')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${view === 'add' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'}`}
                                >
                                    <PlusIcon className="w-5 h-5" />
                                    <span>Ajouter des mots</span>
                                </button>
                                <div className="relative" ref={learnButtonRef}>
                                    <button
                                        onClick={() => hasEnoughVocabularyForQuiz && setIsLearnDropdownOpen((previous) => !previous)}
                                        disabled={!hasEnoughVocabularyForQuiz}
                                        className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${view === 'learn' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'} disabled:opacity-50 disabled:cursor-not-allowed`}
                                        title={!hasEnoughVocabularyForQuiz ? 'Ajoutez au moins 3 mots pour démarrer un quiz' : 'Commencer un quiz'}
                                    >
                                        <LearnIcon className="w-5 h-5" />
                                        <span>Réviser</span>
                                        <ChevronDownIcon
                                            className="w-4 h-4 ml-1 transition-transform"
                                            style={{ transform: isLearnDropdownOpen ? 'rotate(180deg)' : 'rotate(0deg)' }}
                                        />
                                    </button>
                                    {isLearnDropdownOpen && (
                                        <div className="absolute right-0 mt-2 w-52 bg-white rounded-md shadow-lg py-1 z-10 ring-1 ring-black ring-opacity-5">
                                            <button
                                                onClick={() => handleStartQuiz('recent')}
                                                className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100"
                                            >
                                                30 derniers mots
                                            </button>
                                            <button
                                                onClick={() => handleStartQuiz('all')}
                                                className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100"
                                            >
                                                Tous les mots
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <button
                                    onClick={() => hasAnyVocabulary && setView('manage')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${view === 'manage' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'} disabled:opacity-50 disabled:cursor-not-allowed`}
                                    disabled={!hasAnyVocabulary}
                                    title={!hasAnyVocabulary ? 'Ajoutez des mots avant de pouvoir les gérer' : 'Gérer votre collection'}
                                >
                                    <ManageIcon className="w-5 h-5" />
                                    <span>Gérer</span>
                                </button>
                            </nav>
                        </div>
                    </header>
                    <main className="container mx-auto px-4 py-8">
                        {syncError && (
                            <div className="max-w-4xl mx-auto mb-6">
                                <div className="rounded-md bg-red-50 px-4 py-3 text-sm text-red-700 shadow-sm">
                                    {syncError}
                                </div>
                            </div>
                        )}
                        {renderContent()}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
