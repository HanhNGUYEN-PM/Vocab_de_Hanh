<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vocabulary Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fade-in 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-100">
    <div id="root"></div>
    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        const VOCAB_STORAGE_KEY = 'vocabulary-builder-data';

        const generateId = (prefix) => {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        };

        const sanitizeVocabulary = (items) =>
            items
                .filter((item) => item && typeof item === 'object')
                .map((item, index) => ({
                    id: typeof item.id === 'string' && item.id.trim() ? item.id : generateId(`word-${index}`),
                    vietnamese: typeof item.vietnamese === 'string' ? item.vietnamese.trim() : '',
                    chinese: typeof item.chinese === 'string' ? item.chinese.trim() : '',
                    pinyin: typeof item.pinyin === 'string' ? item.pinyin.trim() : '',
                    phonetic: typeof item.phonetic === 'string' ? item.phonetic.trim() : '',
                    hanViet: typeof item.hanViet === 'string' ? item.hanViet.trim() : '',
                    isFavorite: Boolean(item.isFavorite),
                }))
                .filter((item) => item.vietnamese && item.chinese && item.pinyin && item.phonetic && item.hanViet);

        const StarIcon = ({ filled = false, className = '', ...props }) => (
            <svg
                viewBox="0 0 24 24"
                fill={filled ? 'currentColor' : 'none'}
                stroke="currentColor"
                strokeWidth={filled ? 0 : 2}
                strokeLinecap="round"
                strokeLinejoin="round"
                className={className}
                aria-hidden="true"
                {...props}
            >
                <path d="M12 2.75l2.92 5.92 6.54.95-4.73 4.61 1.12 6.52L12 17.77l-5.85 3.08 1.12-6.52-4.73-4.61 6.54-.95L12 2.75z" />
            </svg>
        );

        const CheckIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M20 6L9 17l-5-5" />
            </svg>
        );

        const XIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18" />
                <line x1="6" y1="6" x2="18" y2="18" />
            </svg>
        );

        const PlusIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19" />
                <line x1="5" y1="12" x2="19" y2="12" />
            </svg>
        );

        const EditIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 20h9" />
                <path d="M16.5 3.5a2.121 2.121 0 013 3L7 19l-4 1 1-4L16.5 3.5z" />
            </svg>
        );

        const DeleteIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6" />
                <path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6" />
                <path d="M10 11v6" />
                <path d="M14 11v6" />
                <path d="M9 6V4a1 1 0 011-1h4a1 1 0 011 1v2" />
            </svg>
        );

        const LearnIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M4 19.5v-15l8-2 8 2v15l-8 2-8-2z" />
                <path d="M12 4.5v15" />
            </svg>
        );

        const ManageIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M3 3h18v4H3z" />
                <path d="M9 7v14" />
                <path d="M15 7v14" />
            </svg>
        );

        const ChevronDownIcon = ({ className = '' }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="6 9 12 15 18 9" />
            </svg>
        );

        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i -= 1) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        const Quiz = ({ allVocabulary, questionPool, title, onToggleFavorite, onWrongAnswer }) => {
            const [quizQuestionIds, setQuizQuestionIds] = useState([]);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [score, setScore] = useState(0);
            const [choices, setChoices] = useState([]);
            const [selectedAnswerId, setSelectedAnswerId] = useState(null);
            const [isAnswered, setIsAnswered] = useState(false);
            const [isFinished, setIsFinished] = useState(false);
            const [recentAnswer, setRecentAnswer] = useState(null);
            const autoAdvanceTimeoutRef = useRef(null);
            const voicesRef = useRef([]);

            const currentQuestionId = quizQuestionIds[currentQuestionIndex] ?? null;
            const currentQuestion = useMemo(
                () => questionPool.find((item) => item.id === currentQuestionId) ?? null,
                [currentQuestionId, questionPool]
            );

            const generateNewQuiz = useCallback(() => {
                if (questionPool.length === 0) {
                    setQuizQuestionIds([]);
                    setCurrentQuestionIndex(0);
                    setScore(0);
                    setSelectedAnswerId(null);
                    setIsAnswered(false);
                    setIsFinished(false);
                    return;
                }

                const shuffledPool = shuffleArray(questionPool);
                const selected = shuffledPool.slice(0, Math.min(10, questionPool.length)).map((item) => item.id);
                setQuizQuestionIds(selected);
                setCurrentQuestionIndex(0);
                setScore(0);
                setSelectedAnswerId(null);
                setIsAnswered(false);
                setIsFinished(false);
            }, [questionPool]);

            useEffect(() => {
                if (quizQuestionIds.length === 0 && questionPool.length > 0 && allVocabulary.length >= 3) {
                    generateNewQuiz();
                }
            }, [allVocabulary.length, generateNewQuiz, questionPool.length, quizQuestionIds.length]);

            useEffect(() => {
                if (!currentQuestion) {
                    setChoices([]);
                    return;
                }

                const incorrectAnswers = shuffleArray(allVocabulary.filter((item) => item.id !== currentQuestion.id));
                const selectedIncorrect = incorrectAnswers.slice(0, Math.min(2, incorrectAnswers.length));
                const options = shuffleArray([currentQuestion, ...selectedIncorrect]);
                setChoices(options);
            }, [allVocabulary, currentQuestion]);

            useEffect(() => {
                if (typeof window === 'undefined' || !('speechSynthesis' in window)) {
                    return () => {};
                }

                const synth = window.speechSynthesis;
                const updateVoices = () => {
                    voicesRef.current = synth.getVoices();
                };

                updateVoices();
                synth.addEventListener('voiceschanged', updateVoices);

                return () => {
                    synth.removeEventListener('voiceschanged', updateVoices);
                };
            }, []);

            useEffect(() => () => {
                if (autoAdvanceTimeoutRef.current) {
                    window.clearTimeout(autoAdvanceTimeoutRef.current);
                }
            }, []);

            const speakCurrentWord = useCallback((item) => {
                if (typeof window === 'undefined' || !('speechSynthesis' in window) || typeof SpeechSynthesisUtterance === 'undefined') {
                    return Promise.resolve();
                }

                const synth = window.speechSynthesis;
                if (!synth) {
                    return Promise.resolve();
                }

                synth.cancel();

                const voices = voicesRef.current.length > 0 ? voicesRef.current : synth.getVoices();

                const buildUtterance = (text, primaryLang, fallbackLangs = []) => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    const languagePreferences = [primaryLang, ...fallbackLangs];

                    for (const lang of languagePreferences) {
                        const normalizedLang = lang.toLowerCase();
                        const matchingVoice = voices.find(
                            (voice) => voice.lang && voice.lang.toLowerCase().startsWith(normalizedLang),
                        );
                        if (matchingVoice) {
                            utterance.voice = matchingVoice;
                            break;
                        }
                    }

                    utterance.lang = primaryLang;
                    return utterance;
                };

                const utterances = [];

                if (item.chinese) {
                    utterances.push(buildUtterance(item.chinese, 'zh-CN', ['zh-HK', 'zh-TW', 'zh', 'cmn']));
                }

                if (utterances.length === 0) {
                    return Promise.resolve();
                }

                return new Promise((resolve) => {
                    const speakUtterance = (index) => {
                        if (index >= utterances.length) {
                            resolve();
                            return;
                        }

                        const utterance = utterances[index];

                        const cleanup = () => {
                            utterance.removeEventListener('end', handleEnd);
                            utterance.removeEventListener('error', handleError);
                        };

                        const handleEnd = () => {
                            cleanup();
                            speakUtterance(index + 1);
                        };

                        const handleError = () => {
                            cleanup();
                            speakUtterance(index + 1);
                        };

                        utterance.addEventListener('end', handleEnd);
                        utterance.addEventListener('error', handleError);

                        synth.speak(utterance);
                    };

                    speakUtterance(0);
                });
            }, []);

            const handleAnswer = (selectedId) => {
                if (isAnswered || !currentQuestion) {
                    return;
                }

                setSelectedAnswerId(selectedId);
                setIsAnswered(true);
                setRecentAnswer(currentQuestion);

                const isCorrect = selectedId === currentQuestion.id;

                if (isCorrect) {
                    setScore((prevScore) => prevScore + 1);
                } else {
                    onWrongAnswer(currentQuestion.id);
                }

                if (autoAdvanceTimeoutRef.current) {
                    window.clearTimeout(autoAdvanceTimeoutRef.current);
                }

                const delay = isCorrect ? 1200 : 2000;

                const scheduleAdvance = () => {
                    autoAdvanceTimeoutRef.current = window.setTimeout(() => {
                        handleNextQuestion();
                    }, delay);
                };

                speakCurrentWord(currentQuestion)
                    .catch(() => {
                        // Ignore speech synthesis errors and continue advancing.
                    })
                    .finally(() => {
                        scheduleAdvance();
                    });
            };

            const handleNextQuestion = () => {
                if (quizQuestionIds.length === 0) {
                    return;
                }

                setRecentAnswer(null);

                if (currentQuestionIndex < quizQuestionIds.length - 1) {
                    setCurrentQuestionIndex((previous) => previous + 1);
                    setSelectedAnswerId(null);
                    setIsAnswered(false);
                } else {
                    setIsFinished(true);
                }

                autoAdvanceTimeoutRef.current = null;
            };

            const handleRestart = () => {
                generateNewQuiz();
            };

            const toggleFavorite = () => {
                if (!currentQuestion) {
                    return;
                }

                onToggleFavorite(currentQuestion.id, !currentQuestion.isFavorite);
            };

            const getChoiceClass = (choiceId) => {
                if (!isAnswered) {
                    return 'bg-white hover:bg-indigo-50 border-slate-300';
                }
                if (currentQuestion && choiceId === currentQuestion.id) {
                    return 'bg-green-100 border-green-500 ring-2 ring-green-500';
                }
                if (choiceId === selectedAnswerId) {
                    return 'bg-red-100 border-red-500 ring-2 ring-red-500';
                }
                return 'bg-slate-50 border-slate-200 opacity-60';
            };

            if (questionPool.length === 0 || allVocabulary.length < 3) {
                return (
                    <div className="max-w-2xl mx-auto text-center bg-white p-8 rounded-lg shadow-lg">
                        <h2 className="text-2xl font-bold mb-4 text-slate-700">Quiz indisponible</h2>
                        <p className="text-slate-600">Ajoutez davantage de mots pour pouvoir lancer un quiz.</p>
                    </div>
                );
            }

            if (isFinished) {
                return (
                    <div className="max-w-2xl mx-auto text-center bg-white p-8 rounded-lg shadow-lg">
                        <h2 className="text-3xl font-bold mb-4 text-slate-700">Quiz terminé !</h2>
                        <p className="text-xl text-slate-600 mb-6">Votre score final :</p>
                        <p className="text-6xl font-bold text-indigo-600 mb-8">
                            {score} / {quizQuestionIds.length}
                        </p>
                        <button
                            onClick={handleRestart}
                            className="px-8 py-4 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105"
                        >
                            Recommencer le quiz
                        </button>
                    </div>
                );
            }

            if (!currentQuestion) {
                return <div className="text-center text-slate-500">Chargement du quiz...</div>;
            }

            return (
                <div className="max-w-2xl mx-auto">
                    <div className="text-center mb-4">
                        <h1 className="text-xl font-bold text-slate-600">{title}</h1>
                    </div>
                    <div className="flex justify-between items-center mb-2">
                        <div className="text-sm text-slate-500">
                            Question {currentQuestionIndex + 1} sur {quizQuestionIds.length}
                        </div>
                        <div className="flex items-center gap-3">
                            <div className="text-sm font-semibold text-slate-600 bg-slate-200 px-3 py-1 rounded-full">Score : {score}</div>
                            <button
                                onClick={toggleFavorite}
                                className="flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium transition-colors bg-white border border-slate-200 hover:bg-indigo-50"
                            >
                                <StarIcon
                                    filled={Boolean(currentQuestion.isFavorite)}
                                    className={`w-5 h-5 ${currentQuestion.isFavorite ? 'text-yellow-500' : 'text-slate-400'}`}
                                />
                                <span>{currentQuestion.isFavorite ? 'Favori' : 'Ajouter aux favoris'}</span>
                            </button>
                        </div>
                    </div>
                    <div className="bg-white p-8 rounded-lg shadow-lg mb-6 text-center">
                        <p className="text-lg text-slate-500 mb-2">Quelle est la signification de :</p>
                        <h2 className="text-4xl font-bold text-slate-800">{currentQuestion.vietnamese}</h2>
                    </div>

                    <div className="grid grid-cols-1 gap-4">
                        {choices.map((choice) => (
                            <button
                                key={choice.id}
                                onClick={() => handleAnswer(choice.id)}
                                disabled={isAnswered}
                                className={`p-6 rounded-lg border-2 text-left transition-all duration-300 transform hover:scale-105 disabled:cursor-not-allowed disabled:transform-none ${getChoiceClass(choice.id)}`}
                            >
                                <div className="flex justify-between items-center">
                                    <div>
                                        <p className="text-2xl font-semibold text-slate-800">{choice.pinyin}</p>
                                        <p className="text-sm text-slate-500 mt-1">
                                            {choice.phonetic} • {choice.hanViet}
                                        </p>
                                    </div>
                                    {isAnswered && (
                                        choice.id === currentQuestion.id ? (
                                            <CheckIcon className="w-8 h-8 text-green-600" />
                                        ) : choice.id === selectedAnswerId ? (
                                            <XIcon className="w-8 h-8 text-red-600" />
                                        ) : null
                                    )}
                                </div>
                            </button>
                        ))}
                    </div>

                    {isAnswered && (
                        <div className="mt-8 text-center text-slate-500 text-sm">
                            {currentQuestionIndex < quizQuestionIds.length - 1
                                ? 'Chargement de la question suivante...'
                                : 'Affichage des résultats...'}
                        </div>
                    )}

                    {recentAnswer && (
                        <div className="mt-6 text-center">
                            <div className="inline-block px-4 py-2 bg-green-50 text-green-700 rounded-full font-semibold shadow-sm">
                                Bonne réponse : <span className="font-bold text-green-800">{recentAnswer.chinese}</span>
                            </div>
                            <div className="mt-2 text-sm text-green-600">
                                {recentAnswer.pinyin} • {recentAnswer.phonetic}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const VocabularyManager = ({ vocabulary, onUpdate, onDelete, onToggleFavorite }) => {
            const [editingId, setEditingId] = useState(null);
            const [editedItem, setEditedItem] = useState(null);

            const handleEdit = (item) => {
                setEditingId(item.id);
                setEditedItem({ ...item });
            };

            const handleCancel = () => {
                setEditingId(null);
                setEditedItem(null);
            };

            const handleSave = () => {
                if (editedItem) {
                    onUpdate(editedItem);
                }
                handleCancel();
            };

            const handleDelete = (id, vietnamese) => {
                if (window.confirm(`Are you sure you want to delete "${vietnamese}"?`)) {
                    onDelete(id);
                }
            };

            const handleInputChange = (event) => {
                if (editedItem) {
                    setEditedItem({ ...editedItem, [event.target.name]: event.target.value });
                }
            };

            const renderCell = (field, item) => {
                if (editingId === item.id && editedItem) {
                    return (
                        <input
                            type="text"
                            name={field}
                            value={editedItem[field]}
                            onChange={handleInputChange}
                            className="w-full bg-slate-50 border border-indigo-300 rounded-md px-2 py-1 focus:ring-2 focus:ring-indigo-500 focus:outline-none"
                        />
                    );
                }
                return item[field];
            };

            return (
                <div className="bg-white p-6 md:p-8 rounded-lg shadow-lg animate-fade-in">
                    <h2 className="text-2xl font-bold text-slate-700 mb-6">Manage Vocabulary Collection</h2>
                    <div className="overflow-x-auto">
                        <table className="w-full min-w-[880px] text-sm text-left text-slate-600">
                            <thead className="text-xs text-slate-700 uppercase bg-slate-100">
                                <tr>
                                    <th scope="col" className="px-4 py-3">Vietnamese</th>
                                    <th scope="col" className="px-4 py-3">Chinese</th>
                                    <th scope="col" className="px-4 py-3">Pinyin</th>
                                    <th scope="col" className="px-4 py-3">Phonetic</th>
                                    <th scope="col" className="px-4 py-3">Hán Việt</th>
                                    <th scope="col" className="px-4 py-3 text-center">Favori</th>
                                    <th scope="col" className="px-4 py-3 text-right">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {vocabulary.map((item) => (
                                    <tr key={item.id} className="bg-white border-b hover:bg-slate-50">
                                        <td className="px-4 py-3">{renderCell('vietnamese', item)}</td>
                                        <td className="px-4 py-3">{renderCell('chinese', item)}</td>
                                        <td className="px-4 py-3">{renderCell('pinyin', item)}</td>
                                        <td className="px-4 py-3">{renderCell('phonetic', item)}</td>
                                        <td className="px-4 py-3">{renderCell('hanViet', item)}</td>
                                        <td className="px-4 py-3">
                                            <button
                                                type="button"
                                                onClick={() => onToggleFavorite(item.id)}
                                                className="mx-auto flex items-center justify-center w-9 h-9 rounded-full border border-slate-200 bg-white hover:bg-indigo-50 transition-colors"
                                                title={item.isFavorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}
                                            >
                                                <StarIcon
                                                    filled={Boolean(item.isFavorite)}
                                                    className={`w-5 h-5 ${item.isFavorite ? 'text-yellow-500' : 'text-slate-400'}`}
                                                />
                                            </button>
                                        </td>
                                        <td className="px-4 py-3">
                                            <div className="flex justify-end items-center space-x-2">
                                                {editingId === item.id ? (
                                                    <>
                                                        <button
                                                            onClick={handleSave}
                                                            className="p-2 text-green-600 hover:text-green-800 rounded-full hover:bg-green-100"
                                                            title="Save"
                                                        >
                                                            <CheckIcon className="w-5 h-5" />
                                                        </button>
                                                        <button
                                                            onClick={handleCancel}
                                                            className="p-2 text-slate-500 hover:text-slate-700 rounded-full hover:bg-slate-200"
                                                            title="Cancel"
                                                        >
                                                            <XIcon className="w-5 h-5" />
                                                        </button>
                                                    </>
                                                ) : (
                                                    <>
                                                        <button
                                                            onClick={() => handleEdit(item)}
                                                            className="p-2 text-blue-600 hover:text-blue-800 rounded-full hover:bg-blue-100"
                                                            title="Edit"
                                                        >
                                                            <EditIcon className="w-5 h-5" />
                                                        </button>
                                                        <button
                                                            onClick={() => handleDelete(item.id, item.vietnamese)}
                                                            className="p-2 text-red-600 hover:text-red-800 rounded-full hover:bg-red-100"
                                                            title="Delete"
                                                        >
                                                            <DeleteIcon className="w-5 h-5" />
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const VocabularyInput = ({ onSave, existingVocabulary }) => {
            const [text, setText] = useState('');
            const [error, setError] = useState(null);
            const [successMessage, setSuccessMessage] = useState(null);

            const PLACEHOLDER_TEXT = `Paste your vocabulary here. Each line should have 5 parts separated by tabs.\nExample:\nNgân hàng\t银行\tyínháng dính háng\tngân hàng\nBưu điện\t邮局\tyóujú\tdấu chú bưu cục\n...`;

            const handleParseAndSave = () => {
                setError(null);
                setSuccessMessage(null);
                if (!text.trim()) {
                    setError('Input cannot be empty.');
                    return;
                }

                const lines = text.trim().split('\n');
                const newItems = [];
                let lineError = false;
                const existingVietnameseWords = new Set(existingVocabulary.map((item) => item.vietnamese));
                let skippedCount = 0;

                lines.forEach((line, index) => {
                    if (lineError) return;
                    if (!line.trim()) return;

                    const parts = line.split('\t');
                    if (parts.length !== 5) {
                        setError(`Error on line ${index + 1}: Each line must have exactly 5 parts separated by a tab.`);
                        lineError = true;
                        return;
                    }

                    const [vietnamese, chinese, pinyin, phonetic, hanViet] = parts.map((part) => part.trim());
                    if (!vietnamese || !chinese || !pinyin || !phonetic || !hanViet) {
                        setError(`Error on line ${index + 1}: One of the parts is empty.`);
                        lineError = true;
                        return;
                    }

                    if (existingVietnameseWords.has(vietnamese)) {
                        skippedCount += 1;
                        return;
                    }

                    newItems.push({
                        id: `${Date.now()}-${index}`,
                        vietnamese,
                        chinese,
                        pinyin,
                        phonetic,
                        hanViet,
                        isFavorite: false,
                    });
                });

                if (!lineError) {
                    if (existingVocabulary.length + newItems.length < 3) {
                        setError('You need a total of at least 3 vocabulary words to start the quiz.');
                        return;
                    }
                    if (newItems.length > 0) {
                        onSave(newItems);
                        setSuccessMessage(`${newItems.length} new word(s) added! ${skippedCount > 0 ? `${skippedCount} duplicate(s) skipped.` : ''}`);
                        setText('');
                    } else if (skippedCount > 0) {
                        setError(`All ${skippedCount} entered word(s) were duplicates and have been skipped.`);
                    } else {
                        setError('No new words to add.');
                    }
                }
            };

            return (
                <div className="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-lg animate-fade-in">
                    <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold text-slate-700">Add New Vocabulary</h2>
                        <div className="text-sm font-medium text-slate-500 bg-slate-200 px-3 py-1 rounded-full">
                            {existingVocabulary.length} words in collection
                        </div>
                    </div>
                    <p className="text-slate-600 mb-6">
                        Paste your vocabulary list below. New words will be added to your existing collection. Duplicates will be skipped.
                    </p>

                    <textarea
                        value={text}
                        onChange={(event) => setText(event.target.value)}
                        placeholder={PLACEHOLDER_TEXT}
                        className="w-full h-64 p-4 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-shadow duration-200 resize-none font-mono text-sm"
                    />

                    {error && <p className="text-red-500 mt-4 text-sm font-semibold">{error}</p>}
                    {successMessage && <p className="text-green-600 mt-4 text-sm font-semibold">{successMessage}</p>}

                    <div className="mt-6 flex justify-end">
                        <button
                            onClick={handleParseAndSave}
                            className="px-6 py-3 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105"
                        >
                            Add Words to Collection
                        </button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [vocabulary, setVocabulary] = useState([]);
            const [view, setView] = useState('add');
            const [isLearnDropdownOpen, setIsLearnDropdownOpen] = useState(false);
            const [quizScope, setQuizScope] = useState(null);
            const learnButtonRef = useRef(null);

            const persistVocabulary = useCallback((items) => {
                if (typeof localStorage === 'undefined') {
                    return;
                }

                try {
                    localStorage.setItem(VOCAB_STORAGE_KEY, JSON.stringify(items));
                } catch (error) {
                    console.error('Failed to save vocabulary to local storage:', error);
                }
            }, []);

            useEffect(() => {
                if (typeof window === 'undefined') {
                    return;
                }

                try {
                    const stored = localStorage.getItem(VOCAB_STORAGE_KEY);
                    if (!stored) {
                        return;
                    }

                    const parsed = JSON.parse(stored);
                    if (!Array.isArray(parsed)) {
                        return;
                    }

                    const sanitized = sanitizeVocabulary(parsed);
                    if (sanitized.length === 0) {
                        return;
                    }

                    setVocabulary(sanitized);
                    if (sanitized.length >= 3) {
                        setView('learn');
                        setQuizScope('all');
                    }
                } catch (error) {
                    console.error('Failed to load vocabulary from local storage:', error);
                }
            }, []);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (learnButtonRef.current && !learnButtonRef.current.contains(event.target)) {
                        setIsLearnDropdownOpen(false);
                    }
                };

                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, []);

            const handleSaveVocabulary = useCallback((newItems) => {
                if (newItems.length === 0) {
                    return;
                }

                let updated = [];
                setVocabulary((previousVocabulary) => {
                    const normalizedNewItems = newItems.map((item, index) => ({
                        ...item,
                        id: item.id || generateId(`word-${previousVocabulary.length + index}`),
                        isFavorite: Boolean(item.isFavorite),
                    }));
                    updated = [...previousVocabulary, ...normalizedNewItems];
                    persistVocabulary(updated);
                    return updated;
                });

                setView('learn');
                setQuizScope((previous) => previous ?? 'recent');
            }, [persistVocabulary]);

            const handleDeleteVocabularyItem = useCallback((idToDelete) => {
                let updated = null;
                setVocabulary((previousVocabulary) => {
                    const filtered = previousVocabulary.filter((item) => item.id !== idToDelete);
                    if (filtered.length === previousVocabulary.length) {
                        return previousVocabulary;
                    }

                    updated = filtered;
                    persistVocabulary(filtered);
                    return filtered;
                });

                if (!updated) {
                    return;
                }

                if (updated.length === 0) {
                    setView('add');
                    setQuizScope(null);
                } else if (updated.length < 3 && view === 'learn') {
                    setView('add');
                    setQuizScope(null);
                }
            }, [persistVocabulary, view]);

            const handleUpdateVocabularyItem = useCallback((updatedItem) => {
                setVocabulary((previousVocabulary) => {
                    let changed = false;
                    const updated = previousVocabulary.map((item) => {
                        if (item.id === updatedItem.id) {
                            changed = true;
                            return {
                                ...item,
                                ...updatedItem,
                                isFavorite: Boolean(updatedItem.isFavorite),
                            };
                        }
                        return item;
                    });

                    if (!changed) {
                        return previousVocabulary;
                    }

                    persistVocabulary(updated);
                    return updated;
                });
            }, [persistVocabulary]);

            const handleToggleFavorite = useCallback((id, next) => {
                setVocabulary((previousVocabulary) => {
                    let changed = false;
                    const updated = previousVocabulary.map((item) => {
                        if (item.id !== id) {
                            return item;
                        }

                        const newValue = typeof next === 'boolean' ? next : !item.isFavorite;
                        if (newValue === Boolean(item.isFavorite)) {
                            return item;
                        }

                        changed = true;
                        return {
                            ...item,
                            isFavorite: newValue,
                        };
                    });

                    if (!changed) {
                        return previousVocabulary;
                    }

                    persistVocabulary(updated);
                    return updated;
                });
            }, [persistVocabulary]);

            const handleWrongAnswer = useCallback((id) => {
                setVocabulary((previousVocabulary) => {
                    let changed = false;
                    const updated = previousVocabulary.map((item) => {
                        if (item.id === id && !item.isFavorite) {
                            changed = true;
                            return {
                                ...item,
                                isFavorite: true,
                            };
                        }
                        return item;
                    });

                    if (!changed) {
                        return previousVocabulary;
                    }

                    persistVocabulary(updated);
                    return updated;
                });
            }, [persistVocabulary]);

            const favorites = useMemo(() => vocabulary.filter((item) => item.isFavorite), [vocabulary]);

            const handleStartQuiz = (scope) => {
                setQuizScope(scope);
                setView('learn');
                setIsLearnDropdownOpen(false);
            };

            const hasAnyVocabulary = vocabulary.length > 0;
            const hasEnoughVocabularyForQuiz = vocabulary.length >= 3;
            const hasFavorites = favorites.length > 0;

            const quizVocabulary = useMemo(() => {
                if (quizScope === 'recent') {
                    return vocabulary.slice(-30);
                }
                if (quizScope === 'favorites') {
                    return favorites;
                }
                if (quizScope === 'all') {
                    return vocabulary;
                }
                return [];
            }, [favorites, quizScope, vocabulary]);

            const canStartQuiz = hasEnoughVocabularyForQuiz && quizScope !== null && (quizScope !== 'favorites' || hasFavorites);

            const renderContent = () => {
                switch (view) {
                    case 'add':
                        return <VocabularyInput onSave={handleSaveVocabulary} existingVocabulary={vocabulary} />;
                    case 'learn':
                        if (!canStartQuiz || quizVocabulary.length === 0) {
                            return (
                                <div className="text-center p-8 bg-white rounded-lg shadow-lg">
                                    <h2 className="text-2xl font-bold text-slate-700 mb-4">Bienvenue !</h2>
                                    <p className="text-slate-600 mb-2">Ajoutez au moins 3 mots de vocabulaire pour démarrer un quiz.</p>
                                    <p className="text-slate-600">
                                        Vous pouvez aussi marquer des favoris pour vous concentrer sur les mots les plus difficiles.
                                    </p>
                                </div>
                            );
                        }

                        const quizTitle =
                            quizScope === 'recent'
                                ? 'Quiz : 30 derniers mots'
                                : quizScope === 'favorites'
                                ? 'Quiz : Mots favoris'
                                : 'Quiz : Tous les mots';

                        return (
                            <Quiz
                                key={`${quizScope}-${quizVocabulary.length}`}
                                allVocabulary={vocabulary}
                                questionPool={quizVocabulary}
                                title={quizTitle}
                                onToggleFavorite={handleToggleFavorite}
                                onWrongAnswer={handleWrongAnswer}
                            />
                        );
                    case 'manage':
                        return hasAnyVocabulary ? (
                            <VocabularyManager
                                vocabulary={vocabulary}
                                onUpdate={handleUpdateVocabularyItem}
                                onDelete={handleDeleteVocabularyItem}
                                onToggleFavorite={handleToggleFavorite}
                            />
                        ) : (
                            <div className="text-center p-8 bg-white rounded-lg shadow-lg">
                                <h2 className="text-2xl font-bold text-slate-700 mb-4">Aucun mot à gérer</h2>
                                <p className="text-slate-600">Votre collection de vocabulaire est vide.</p>
                                <p className="text-slate-600">Ajoutez quelques mots dans l'onglet « Ajouter des mots ».</p>
                            </div>
                        );
                    default:
                        return null;
                }
            };

            return (
                <div className="min-h-screen bg-slate-100 text-slate-800 font-sans">
                    <header className="bg-white shadow-md">
                        <div className="container mx-auto px-4 py-4 flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
                            <div>
                                <h1 className="text-2xl font-bold text-slate-700 tracking-tight">Vocabulary Builder</h1>
                                <p className="text-xs mt-1 text-slate-500">
                                    Vos mots sont enregistrés dans ce navigateur. Marquez des favoris pour les revoir rapidement.
                                </p>
                            </div>
                            <nav className="flex flex-wrap gap-2">
                                <button
                                    onClick={() => setView('add')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                                        view === 'add' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'
                                    }`}
                                >
                                    <PlusIcon className="w-5 h-5" />
                                    <span>Ajouter des mots</span>
                                </button>
                                <div className="relative" ref={learnButtonRef}>
                                    <button
                                        onClick={() => hasEnoughVocabularyForQuiz && setIsLearnDropdownOpen((previous) => !previous)}
                                        disabled={!hasEnoughVocabularyForQuiz}
                                        className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                                            view === 'learn' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'
                                        } disabled:opacity-50 disabled:cursor-not-allowed`}
                                        title={!hasEnoughVocabularyForQuiz ? 'Ajoutez au moins 3 mots pour démarrer un quiz' : 'Commencer un quiz'}
                                    >
                                        <LearnIcon className="w-5 h-5" />
                                        <span>Réviser</span>
                                        <ChevronDownIcon
                                            className="w-4 h-4 ml-1 transition-transform"
                                            style={{ transform: isLearnDropdownOpen ? 'rotate(180deg)' : 'rotate(0deg)' }}
                                        />
                                    </button>
                                    {isLearnDropdownOpen && (
                                        <div className="absolute right-0 mt-2 w-56 bg-white rounded-md shadow-lg py-1 z-10 ring-1 ring-black ring-opacity-5">
                                            <button
                                                onClick={() => handleStartQuiz('recent')}
                                                className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100"
                                            >
                                                30 derniers mots
                                            </button>
                                            <button
                                                onClick={() => handleStartQuiz('all')}
                                                className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100"
                                            >
                                                Tous les mots
                                            </button>
                                            <button
                                                onClick={() => handleStartQuiz('favorites')}
                                                disabled={!hasFavorites}
                                                className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed"
                                            >
                                                Mots favoris
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <button
                                    onClick={() => hasAnyVocabulary && setView('manage')}
                                    className={`flex items-center space-x-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                                        view === 'manage' ? 'bg-indigo-600 text-white shadow-sm' : 'bg-white text-slate-600 hover:bg-slate-100'
                                    } disabled:opacity-50 disabled:cursor-not-allowed`}
                                    disabled={!hasAnyVocabulary}
                                    title={!hasAnyVocabulary ? 'Ajoutez des mots avant de pouvoir les gérer' : 'Gérer votre collection'}
                                >
                                    <ManageIcon className="w-5 h-5" />
                                    <span>Gérer</span>
                                </button>
                            </nav>
                        </div>
                    </header>

                    <main className="container mx-auto px-4 py-8">{renderContent()}</main>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
